# TODO: also include the gatekeeper API
# TODO: if a method could take very long, make it oneway (=asynchronous)

module org {
module oor {
module persistence {

  typedef sequence<char> Blob;

  typedef string Text;
  typedef sequence<string> TextList;

  struct Iri {
    Text iriText;
  };
  typedef sequence<Iri> IriList;

  struct Symbol {
    Iri iri;
    Text kind;
  };
  typedef sequence<Symbol> SymbolList;

  struct Sentence {
    Iri iri;
    Text form;
  };
  typedef sequence<Sentence> SentenceList;

  struct Language {
    Iri iri;
    Text name;
  };
  typedef sequence<Language> LanguageList;

  struct Logic {
    Iri iri;
    Text name;
  };
  typedef sequence<Logic> LogicList;

  struct Metrics {
    Iri iri;
    Text name;
    Text value;
  };
  typedef sequence<Metrics> MetricsList;

  struct Note {
    Iri iri;
    Iri authorIri;
    Text authorName;
    Iri entryIri;
    Text entryComment;
  };
  typedef sequence<Note> NoteList;

  struct Metadatum {
    Iri iri;
    Iri kindIri;
    Iri kindName;
    Iri entryIri;
    Text value;
  };
  typedef sequence<Metadatum> MetadatumList;

  struct OntologyFractum { # TM: synchromize this with OMV
    Iri iri;
    Text name;
    Text description;
    TextList categories;
    TextList groups;
    TextList prefixes;
    Iri languageIri;
    Iri projectIri;
    Iri currentVersionIri;
  };
  typedef sequence<OntologyFractum> OntologyFractumList;

  struct OntologyVersionContent {
    Iri iri;
    Blob blob;
    SymbolList symbolList;
    SentenceList sentenceList;
    MetricsList metricsList;
    NoteList noteList;
    MetadatumList metadatumList;
  };
  typedef sequence<OntologyVersionContent> OntologyVersionContentList;

  struct OntologyContent {
    OntologyFractum fractum;
    OntologyVersionContent currentVersion;
  };
  typedef sequence<OntologyContent> OntologyContentList;

  struct RepositoryFractum {
    Iri iri;
    Text name;
    OntologyFractumList ontologyFractumList;
  };
  typedef sequence<RepositoryFractum> RepositoryFractumList;

  struct RepositoryContent {
    Iri iri;
    Text name;
    OntologyContentList ontologyContentList;
  };
  typedef sequence<RepositoryContent> RepositoryContentList;

  interface Ontology {
    Text getName(in Iri iri);
    Text getDescription(in Iri iri);
    TextList getCategories(in Iri iri); # TM: should be covered by meta ontology
    TextList getGroups(in Iri iri);
    TextList getPrefixes(in Iri iri);
    Iri getCurrentVersionIri(in Iri iri);
    void setName(in Iri iri, in Text name);
    void setDescription(in Iri iri, in Text description);
    void setCategories(in Iri iri, in TextList categories);
    void addCateogry(in Iri iri, in Text category);
    void delCategory(in Iri iri, in Text category);
    void setGroups(in Iri iri, in TextList groups);
    void addGroup(in Iri iri, in Text group);
    void delGroup(in Iri iri, in Text group);
    void setPrefixes(in Iri iri, in TextList prefixes);
    void addPrefix(in Iri iri, in Text prefix);
    void delPrefix(in Iri iri, in Text prefix);
    void setCurrentVersionIri(in Iri iri);

    void getFractum(in Iri iri, out OntologyFractum fractum);
    void getContent(in Iri iri, out OntologyContent content);
    void setFractum(in Iri iri, in OntologyFractum fractum);
    void setContent(in Iri iri, in OntologyContent content);

    void getVersionIriList(in Iri iri, out Iri versionIriList);
    void setVersionIriList(in Iri iri, in Iri versionIriList);
    void addVersionIri(in Iri iri, in Iri versionIri);
    void delVersionIri(in Iri iri, in Iri versionIri);
  };

  interface OntologyVersion {
    void getBlob(in Iri iri);
    void getSymbolList(in Iri iri, out SymbolList symbolList);
    void getSentenceList(in Iri iri, out SentenceList sentenceList);
    void getMetricsList(in Iri iri, out MetricsList metricsList);
    void getNoteList(in Iri iri, out NoteList noteList);
    void getMetadatumList(in Iri iri, out MetadatumList metadatumList);
    void setSymbolList(in Iri iri, in SymbolList symbolList);
    void addSymbol(in Iri iri, in Symbol symbol);
    void delSymbol(in Iri iri, in Iri symbolIri);
    void setSentenceList(in Iri iri, in SentenceList sentenceList);
    void addSentence(in Iri iri, in Sentence sentence);
    void delSentence(in Iri iri, in Iri sentenceIri);
    void setMetricsList(in Iri iri, in MetricsList metricsList);
    void addMetrics(in Iri iri, in Metrics metrics);
    void delMetrics(in Iri iri, in Iri metricsIri);
    void setNoteList(in Iri iri, in NoteList noteList);
    void addNote(in Iri iri, in Note note);
    void delNote(in Iri iri, in Iri noteIri);
    void setMetadatumList(in Iri iri, in MetadatumList metadatumList);
    void addMetadatum(in Iri iri, in Metadatum metadatum);
    void delMetadatum(in Iri iri, in Iri metadatumIri);

    void getContent(in Iri iri, out OntologyVersionContent content);
    void setContent(in Iri iri, in OntologyVersionContent content);
  };

  interface Repository {
    Text getName(in Iri iri);
    void setName(in Iri iri, in Text name);

    void getOntologyIriList(in Iri iri, out IriList ontologyIriList);
    void getOntologyFractumList(in Iri iri, out OntologyFractumList ontologyFractumList);
    void getOntologyContentList(in Iri iri, out OntologyContentList ontologyContentList);
    void getRepositoryFractum(in Iri iri, out RepositoryFractum repositoryFractum);
    void getRepositoryContent(in Iri iri, out RepositoryContent repositoryContent);
    void setOntologyIriList(in Iri iri, in IriList ontologyIriList);
    void addOntology(in Iri iri, in Iri ontologyIri);
    void delOntology(in Iri iri, in Iri ontologyIri);
    void setRepositoryFractum(in Iri iri, in RepositoryFractum repositoryFractum);
    void setRepositoryContent(in Iri iri, in RepositoryContent repositoryContent);
  };

  interface OntologyBase {
# TM: the idea was to have one very powerful method for searching for ontologies
# we have agreed to Todd's suggestion:
# The API for'selecting' is effectively a query mechanism, the front end to 
# the user. The other side of this is the 'retrieving' of the requested or 
# queried data. For the front end of selecting or querying for ontologies 
# (or metadata about them) use of an instance of the metadata ontology should 
# be used as the single parameter for the 'select' method. The particular 
# parameters of interest would be represented by non-null values (in the 
# ontology instance). This simplifies the API and overall architecture 
# (but moves complexity to the parsing of the ontology instance). The 
# retrieval (or return values) of the'selected' results would make use 
# of federate identifiers. 
# the single parameter should be a struct
#
# the user should be able to select whether the method call should just 
# deliver ids (compact representation) or all the metadata (say, as an XML 
# tree), or even the whole ontology/ies (can become very large) 

    void selectOntologyIriList(in Text name, in Text category, in Text group, in Iri languageIri, in Iri projectIri, out IriList iriList);
    void selectOntologyIriListByName(in Text name, out IriList iriList);
    void selectOntologyIriListByCategory(in Text category, out IriList iriList);
    void selectOntologyIriListByGroup(in Text group, out IriList iriList);
    void selectOntologyIriListByLanguageIri(in Iri languageIri, out IriList iriList);
    void selectOntologyIriListByProjectIri(in Iri projectIri, out IriList iriList);
    void getOntologyIriList();

    void selectOntologyFractumList(in Text name, in Text category, in Text group, in Iri languageIri, in Iri projectIri, out OntologyFractumList fractumList);
    void selectOntologyFractumListByName(in Text name, out OntologyFractumList fractumList);
    void selectOntologyFractumListByCategory(in Text category, out OntologyFractumList fractumList);
    void selectOntologyFractumListByGroup(in Text group, out OntologyFractumList fractumList);
    void selectOntologyFracutmListByLanguageIri(in Iri languageIri, out OntologyFractumList fractumList);
    void selectOntologyFractumListByProjectIri(in Iri projectIri, out OntologyFractumList fractumList);
    void getOntologyFractumList();

    void selectOntologyContentList(in Text name, in Text category, in Text group, in Iri languageIri, in Iri projectIri, out OntologyContentList contentList);
    void selectOntologyContentListByName(in Text name, out OntologyContentList contentList);
    void selectOntologyContentListByCategory(in Text category, out OntologyContentList contentList);
    void selectOntologyContentListByGroup(in Text group, out OntologyContentList contentList);
    void selectOntologyContentListByLanguageIri(in Iri languageIri, out OntologyContentList contentList);
    void selectOntologyContentListByProjectIri(in Iri projectIri, out OntologyContentList contentList);
    void getOntologyContentList();

    void insertOntology(in OntologyContent ontologyContent, out Iri iri);
    void updateOntology(in OntologyContent ontologyContent);
    void removeOntology(in Iri iri);
  };

  interface RepositoryBase {
    void selectRepositoryIriList(in Text name, out IriList iriList);

    void selectRepositoryFractumList(in Text name, out RepositoryFractumList repositoryFractumList);

    void selectRepositoryContentList(in Text name, out RepositoryContentList repositoryContentList);

    void insertRepository(in RepositoryContent repositoryContent, out Iri iri);
    void updateRepository(in RepositoryContent repositoryContent);
    void removeRepository(in Iri iri);
  };

};
};
};

